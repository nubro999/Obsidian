
==silent action==
mina 스마트 컨트랙트가 verifier / 서킷은 웹페이지에 고정/ 유저가 서킷에 비밀번호를 넣는다. proof를 생성/ mina verifier 에게 전달
클라이언트는 코드를 소유함. zk-서킷은 공개정보이기 때문에 클라이언트가 소유함

==zk-SNARKs==
- **Zero-Knowledge(영지식)**:  
    "내가 어떤 사실을 안다는 것"을 **그 사실 자체를 공개하지 않고** 증명할 수 있음  
    (예: 내가 비밀번호를 알고 있다는 걸, 비밀번호를 말하지 않고 증명)
- **Succinct(간결함)**:  
    증명서(Proof)의 크기가 매우 작고, 검증이 빠름
- **Non-interactive(비대화형)**:  
    증명 과정이 한 번의 메시지로 끝남(질문-답변 반복 없음)
- **Argument of Knowledge(지식의 증명)**:  
    실제로 그 정보를 알고 있다는 것만 증명

 1. **Prover(증명자)**:  
    어떤 조건(예: "나는 잔고가 10 이상이다")이 **참이라는 것을 알고 있음**
2. **Verifier(검증자)**:  
    그 조건이 참임을 **직접적인 정보 없이도** 확인하고 싶음
3. **Prover**는 zk-SNARKs 알고리즘을 이용해 **짧은 증명서(Proof)**를 생성
4. **Verifier**는 이 증명서를 받아,  
    실제 데이터(잔고, 비밀번호 등)를 보지 않고도  
    "증명자가 정말로 조건을 알고 있구나"를 검증

5. **회로(또는 산술적 제약)로 변환**
    - 증명하고 싶은 명제를 **산술회로(Arithmetic Circuit)**로 변환
    - 예: "x의 해시값이 y와 같다" → 회로로 표현
6. **설정(Setup) 단계**
    - 시스템 전체에 필요한 **공개 파라미터**를 생성
    - (이 과정이 신뢰할 수 있어야 함. 최근에는 이 문제를 해결한 "transparent SNARKs"도 연구 중)
7. **증명(Proof 생성) 단계**
    - Prover가 비밀 데이터와 회로, 공개 파라미터를 이용해 **Proof** 생성
8. **검증(Verification) 단계**
    - Verifier는 Proof와 공개 입력, 공개 파라미터만으로 검증


==Wireshark를 사용한 분석방법==

:wire shark란 네트워크 트래픽을 캡쳐하고 각 패킷의 내용을 상세히 분석할 수 있는 대표적인 프로토콜 분석기술
tcp, udp, http, tls지원
① 3-way Handshake 확인
소켓 연결 시, SYN → SYN-ACK → ACK 순서로 패킷이 오가는지 확인
② 데이터 송수신 패킷 확인
실제 데이터가 오가는 패킷은 Info 컬럼에 [PSH, ACK]가 표시됨
패킷을 클릭하면 하단에서 Payload(실제 전송 데이터) 확인 가능
③ 연결 종료 (4-way handshake)
FIN, ACK 패킷을 통해 연결 종료 과정을 추적
. Raw 데이터 확인
하단의 Packet Bytes 창에서 실제 전송된 바이트 값을 16진수/ASCII로 확인 가능
![[Pasted image 20250709082247.png]]
rpc서버는 함수를 호출하는 서버 http/ tcp를 사용함
웹서버는 웹 페이지나 정적/동적 리소스

스레드는 **프로세스 내에서 실행되는 작업의 단위**입니다.

하나의 프로세스는 여러 개의 스레드를 가질 수 있습니다(멀티스레딩).

모든 스레드는 동일한 프로세스의 자원(메모리, 파일 등)을 공유합니다.



==Recordii / 스레드 최적화 방법, 어떤 라이브러리를 사용했나, clean architecture를 사용한 이유, room db, 데이터 보안 방식, 지연 최소화==
[[Clean architecture]]
:
소프트웨어 시스템의 의존성 방향을 명확히 하여, 비즈니스 규칙(도메인 로직)을 외부 요소(프레임워크, UI, DB 등)로부터 독립시키는 데 목적

의존성 역전(Dependency Inversion):
핵심 비즈니스 로직은 외부에 의존하지 않고, 외부가 내부에 의존하도록 만든다.

테스트 용이성(Testability):
외부 시스템에 영향을 받지 않고, 도메인 로직을 독립적으로 테스트할 수 있다.

유지보수성(Maintainability):
변경이 잦은 외부 요소와 핵심 로직을 분리하여, 시스템의 유지보수를 쉽게 한다.

확장성(Extensibility):
새로운 UI, DB, 프레임워크 교체가 쉽다.

Entities (엔터티, 도메인 레이어)

시스템의 핵심 비즈니스 규칙과 객체
예: 계좌, 주문, 사용자 등 도메인 모델
Use Cases (유스케이스, 애플리케이션 레이어)

애플리케이션의 특정 작업/프로세스(비즈니스 규칙)를 구현
예: "송금하기", "주문 생성"
Interface Adapters (인터페이스 어댑터)

외부와 내부의 데이터 변환, 입출력 어댑터
예: Controller, Presenter, Repository 구현체
Frameworks & Drivers (프레임워크와 드라이버)

실제 DB, UI, 웹 프레임워크, 외부 시스템 등
예: Spring, Django, MySQL, REST API 등

3. Clean Architecture의 장점
4. 비즈니스 로직의 독립성
UI, DB, 프레임워크, 외부 라이브러리와 완전히 분리
핵심 로직이 외부 변화에 영향을 받지 않음

5. 높은 테스트 용이성
외부 시스템을 Mocking하여, 도메인/유스케이스 단위의 테스트가 매우 쉬움

6. 유지보수성/확장성
UI, DB, 프레임워크 교체 시, 핵심 로직은 거의 수정하지 않아도 됨
새로운 인터페이스 추가가 용이

7. 의존성 방향의 명확성
코드베이스가 커져도 아키텍처적 혼란이 적음
팀원 간 협업 및 코드 이해가 쉬움

8. SRP(단일 책임 원칙) 준수
각 계층이 명확한 책임을 가짐

### 레이어드 멀티 모듈 구조

관심사의 분리(Separation of Concerns)

각 레이어(예: presentation, domain, data)가 명확하게 역할을 나누어 담당
코드의 복잡성을 줄이고, 유지보수성을 높임
모듈화(Modularity)

각 레이어를 별도의 모듈(Project/Gradle Module)로 분리
독립적인 개발, 빌드, 테스트가 가능
의존성 관리 용이

상위 레이어가 하위 레이어에만 의존하도록 설계(단방향 의존성)
불필요한 의존성을 방지하고, 아키텍처의 일관성을 유지
재사용성 증가

도메인 로직(domain), 데이터 접근(data) 등 공통 기능을 다른 프로젝트에서도 쉽게 재사용 가능
유지보수 및 확장성 향상

한 레이어(모듈)의 변경이 다른 레이어에 미치는 영향을 최소화
새로운 기능 추가, 기술 교체(DB, UI 등)가 쉬움

- **Presentation Layer**  
    : UI, View, ViewModel, 화면 관련 로직, 사용자와 상호작용하는 부분
- **Domain Layer**  
    : 비즈니스 로직, UseCase, Entity 등
- **Data Layer**  
    : Repository 구현, 데이터 소스(DB, Network 등)

- **UI/화면 관련 파일들이 위치**
    - `NotesScreen.kt`, `NoteDetailsScreen.kt`, `NoteFolderDetailsScreen.kt` 등:  
        각각의 화면(View, UI 컴포넌트)에 해당하는 코드
- **ViewModel 포함**
    - `NotesViewModel`, `NoteDetailsViewModel`:  
        화면 상태관리, 유저 액션 처리 등 Presentation Layer의 핵심 역할
- **이벤트/상태 관리**
    - `NoteEvent`, `NoteDetailsEvent.kt`:  
        UI에서 발생하는 다양한 이벤트(버튼 클릭, 입력 등)를 정의
- **DI(Dependency Injection) 모듈**
    - `NotePresentationModule`:  
        Presentation Layer에서 사용할 의존성 주입 설정

presentation > domain < data

Gradle은

프로젝트 빌드, 의존성 관리, 테스트, 배포 등을 자동화하는 빌드 도구입니다.
안드로이드 프로젝트에서는 build.gradle(.kts) 파일을 통해
플러그인 적용, 컴파일 옵션, 의존성 추가, 빌드 타입 정의 등
다양한 빌드 관련 설정을 관리합니다.

- **KSP**(Kotlin Symbol Processing) 지원:  
    주로 DI(의존성 주입)나 코드 생성 라이브러리 사용 시 필요
- **다른 모듈 의존성 추가**
    - `:core:database`: 데이터베이스 관련 공통 모듈
    - `:notes:domain`: 도메인 레이어(비즈니스 로직) 모듈
- **외부 라이브러리 추가**
    - `koin`: DI(의존성 주입) 라이브러리
    - `junit`, `androidx.junit`: 테스트 라이브러리
    - `ksp`: Koin DI 코드 생성을 위한 컴파일러 ==di 코드는 어떤 식으로 생성되나?==

1. **객체 생성 및 주입 방식 정의**
    - 어떤 클래스가 어떤 의존성을 필요로 하는지 명시
2. **의존성의 라이프사이클 관리**
    - 싱글톤(single), 팩토리(factory) 등으로 객체 생명주기 제어
3. **관심사 분리**
    - 객체 생성/연결 로직을 분리하여  
        비즈니스 로직과 UI 코드가 깔끔해짐
4. **테스트 용이성 증가**
    - 테스트 시 Mock 객체 등 쉽게 주입 가능

single : MyRepository는 한 번만 생성해서 모두가 공유
factory : MyViewModel은 필요한 시점마다 새로 생성

- **@Dao**:  
    이 인터페이스가 Room에서 데이터 접근 객체임을 나타냅니다.
- **NoteEntity**:  
    노트 테이블의 각 행(노트 한 개)을 나타내는 데이터 클래스
- **NoteFolderEntity**:  
    폴더 테이블의 각 행(폴더 한 개)을 나타내는 데이터 클래스

- **suspend**: 코루틴에서 비동기로 사용


# 1. 스레드 최적화란?

- **스레드(Thread)**: 프로그램이 동시에 여러 작업을 처리할 수 있게 해주는 실행 단위
- **최적화(Optimization)**: 스레드를 효율적으로 관리해서 CPU, 메모리 등 자원을 낭비하지 않고 최대한 빠르게 작업을 처리하는 것

## **왜 중요할까?**

- 불필요하게 많은 스레드를 만들면 오히려 느려지고,  
    적절히 나누지 않으면 UI가 멈추거나 느려질 수 있음

---

# 2. 지연 최소화란?

- **지연(Latency)**:  
    어떤 작업을 시작했을 때 결과가 나오기까지 걸리는 시간
- **최소화(Minimization)**:  
    이 시간을 최대한 줄여서, 사용자에게 빠른 피드백과 반응을 제공하는 것

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    // 백그라운드에서 실행 (CPU 연산)
    val job = launch(Dispatchers.Default) {
        // heavy task
        println("Heavy work on thread: ${Thread.currentThread().name}")
    }
    job.join()
}
```

- 코루틴 디스패처(Dispatchers.Default, IO)는 내부적으로 스레드 풀을 사용

- **비동기 처리**: 오래 걸리는 작업은 반드시 비동기로 처리
- **코루틴의 async/await**: 여러 작업을 동시에 실행하여 전체 지연시간 단축
- **네트워크/DB 최적화**: 쿼리, API 호출 최소화 및 효율적으로 설계
- **Debounce/Throttle**: 사용자의 빠른 입력 등에서 불필요한 연산 줄이기

- **UI 관련 작업**은 반드시 메인(UI) 스레드에서!
- **무거운 작업(네트워크, DB 등)**은 백그라운드에서!

### **1) 코루틴 기반 비동기 처리**

- Kotlin 코루틴은 스레드를 직접 만들거나 관리하지 않고,  
    **필요할 때만 적절한 스레드 풀에서 작업을 실행**합니다.
- 비동기 네트워크 요청이나 I/O 작업이  
    **메인(UI) 스레드를 차단하지 않고** 백그라운드에서 실행됩니다.

### **2) IO 전용 스레드 풀 활용**

- `Dispatchers.IO`는 네트워크, 파일 입출력 등  
    **입출력(I/O) 작업에 최적화된 스레드 풀**을 제공합니다.
- CPU 자원을 효율적으로 사용하고,  
    **필요 이상으로 많은 스레드를 만들지 않음**  
    → 오버헤드 최소화, 성능 최적화

### **3) 코드의 가독성과 유지보수성 향상**

- 스레드 관리 코드가 필요 없고,  
    코루틴 블록 안에서 동기식 코드처럼 작성 가능  
    → 개발이 쉬워짐

STT 부분

- **콜백 기반 API → Flow 변환**  
    → 앱에서 실시간 상태 구독 가능
- **메인 스레드 안전성** 보장  
    (SpeechRecognizer 관련 작업은 반드시 메인에서)
- **자원 정리** 자동화  
    (Flow 종료 시 SpeechRecognizer 정리)
- **상태 관리**가 명확  
    (UI에서 다양한 인식 상태 쉽게 처리)

- Flow 내부에서 값을 내보낼 때,  
    **코루틴 환경**(suspend 함수, 코루틴 스코프 등)에서 동작함
- Flow의 연산자(map, filter 등)와 collect도 모두 코루틴에서 실행
### **3) Flow는 여러 값을 "차례대로", 코루틴은 한 번에 하나의 작업**

- 코루틴: 한 번에 하나의 suspend 함수 실행
- Flow: 여러 값을 차례로 내보내며, 각 값을 코루틴에서 받아 처리

### **4) Flow는 코루틴의 "스트림 버전"**

- 코루틴이 단일 값의 비동기 처리라면,  
    Flow는 **여러 값의 비동기 스트림** 처리


- **콜백(Callback)**:  
    작업이 끝나면 호출되는 함수를 등록  
    (예: Java의 `AsyncTask`, Android의 `setOnClickListener`)
- **Future/Promise**:  
    미래에 결과가 준비되면 알려주는 객체  
    (예: JavaScript의 Promise, Java의 CompletableFuture)
- **코루틴(Coroutine)**:  
    Kotlin, Python 등에서 지원하는 비동기 프로그래밍 방식  
    (코드를 동기식처럼 작성 가능)
- **RxJava, Flow**:  
    비동기 데이터 스트림을 다루는 라이브러리

CallbackFlow 
**콜백 기반의 비동기 이벤트를 Kotlin의 Flow로 바꿔주는 도구입니다**
콜백 : 비동기함수에서 나중에 처리할 것 지정, 함수 호출 순서 지정

TypeScript:

JS 기반, 타입은 컴파일 타임에만 존재, 널 안전은 옵션,
비동기는 Promise/async-await, 함수형 지원은 상대적으로 약함
Kotlin:

JVM 기반, 널 안전 강제, 코루틴 내장, 함수형 프로그래밍 강력 지원,
다양한 플랫폼(안드로이드, 서버 등) 지원


==어떻게 next.js를 활용해 사용자 친화적인 인터페이스를 구현했고 api호출과 서버, ui 는 어떻게 구현했나?==

: 디자인 원리를 이용했습니다. 문제를 정의할 때 기술이 아닌 사용자의 관점에서 어떻게 해야 더 접근하기 쉬울까를 생각했고, LLM을 사용해서 최대한 요구사항을 잘제시하는 쪽으로 프로그래밍했습니다.

==bitcoin백서에서 보안에 관련된 항목, 어떻게 본질이 현상이 되었나?==

: 탈중앙화(Decentralization)
중앙은행, 정부 등 중앙 기관 없이 네트워크 참여자들이 직접 거래를 검증하고 기록
누구도 임의로 조작하거나 통제할 수 없음
중앙 기관 없이도 '코드'와 '수학'만으로 신뢰를 구축

 -> 공개키/개인키 쌍으로 검증
	 분산 네트워크
	 합의 알고리즘
	 암호학적 해시함수 - 머클트리
	 
국경, 은행, 시간에 구애받지 않고 누구나, 언제든, 어디서든 직접 송금 가능
모든 거래 내역이 공개되어 누구나 검증 가능
-> 부패, 조작 가능성 최소화

==DID(분산신원인증)기술==
: [[DID]]

 ==지문인식과 결합하는 방식==
:

==Fuzzy Extractor==
:
Fuzzy Extractor는 생체정보(지문, 홍채, 음성 등)처럼 입력값이 항상 조금씩 달라지는(노이즈가 있는) 데이터를
암호학적으로 안전한 비밀키로 변환하는 기술입니다.

### 1) **생성(Generate) 단계**

- **입력값(w)**: 예를 들어 지문 데이터
- **출력값**:
    - **비밀키(R)** (암호학적으로 무작위)
    - **공개 보조정보(P)** (나중에 복원에 사용, 공개되어도 안전)

### 2) **복원(Reproduce) 단계**

- **입력값(w')**: 원래 입력값과 약간 다른 값(다른 날 찍은 지문 등)
- **공개 보조정보(P)**와 함께 사용
- **출력값**:
    - 원래와 동일한 **비밀키(R)**

#### 요약:

조금 다른 입력(w')에도, 공개 보조정보(P)만 있으면  
**항상 같은 비밀키(R)**를 뽑아낼 수 있음

---

## 4. **기술적 예시**

- **Error Correcting Code(오류 정정 코드)**를 활용
    - 입력값에서 오류 정정 코드를 통해 노이즈를 보정
    - 해시 함수를 적용해 무작위 키로 변환

#### 예시 흐름

1. **지문 데이터 → 오류 정정 코드 적용 → 비밀키(R) 및 보조정보(P) 생성**
2. **다음번 지문 데이터 → 오류 정정 코드로 보정 → 보조정보(P)와 결합 → 비밀키(R) 재생성**

3. 알고리즘 흐름 요약
생성:
생성:

입력 w, 코드 C
임의 코드워드 c ∈ C
P = w ⊕ c
R = Hash(c)
복원:
복원:

입력 w′, 보조정보 P
c′ = w′ ⊕ P
c = \text{Decode}_C(c′)
R = Hash(c)
4. 예시
w: 1011010 (원래 입력)
c: 1100110 (코드워드)
P = w ⊕ c = 0111100
R = Hash(1100110)
복원 시:

w′: 1011011 (노이즈 1비트)
c′ = w′ ⊕ P = 1100111
오류 정정 코드로 c′ → c(1100110) 복원
R = Hash(1100110) (원래와 동일한 키)
5. 정리
보조정보 P는 입력과 코드워드의 XOR
복원 시 새로운 입력과 P를 XOR, 오류 정정 코드로 원래 코드워드 복원
Hash로 암호학적으로 안전한 비밀키 생성

==대칭키==
:



==리버스 엔지니어링==
소프트웨어 리버스 엔지니어링은 프로그램이 실제로 어떻게 동작하는지를 분해해서 역으로 분석하는 기술
![[Pasted image 20250709202554.png]]

1. **파이프라인(Pipeline)**
    - 명령을 여러 단계로 나눠 동시에 처리하여 성능 향상
2. **슈퍼스칼라(Superscalar)**
    - 한 사이클에 여러 명령을 동시에 실행
3. **Out-of-order 실행**
    - 명령의 순서를 유동적으로 바꿔 효율적으로 실행
4. **분기 예측(Branch Prediction)**
    - 분기 명령(조건문 등)에서 다음에 실행할 명령을 미리 예측
5. **캐시 계층 구조(Cache Hierarchy)**
    - L1, L2, L3 캐시 등 다양한 크기/속도의 캐시 메모리 설계
6. **멀티코어(Multi-core)**
    - 하나의 칩 안에 여러 개의 CPU 코어를 집적

실기 문제
==A==

==B==

==C==

==D==

==E==

==F==

==G==

H

I

J

K

L

M

N
어셈블러 명령어
### 1. **eax란?**

- **rax**: 64비트 레지스터
- **eax**: rax의 **하위 32비트(4바이트)** 부분

### 2. **값 분석**

- rax = 0x0123456789abcdef  
    (16진수 16자리 = 64비트)

16진수 자리별로 나누면:

- 0x01 23 45 67 89 ab cd ef  
    (각각 1바이트씩, 왼쪽이 상위 바이트)

**하위 32비트** = 맨 오른쪽 8자리(16진수)


|   |   |   |
|---|---|---|
|rax|0x0123456789abcdef|전체 64비트|
|eax|0x89abcdef|하위 32비트|
|ax|0xcdef|하위 16비트|
|ah|0xcd|하위 2바이트 중 상위|
|al|0xef|하위 1바이트|


==O==

==P==

==Z==
redis
: 인메모리 저장: 모든 데이터를 메모리(RAM)에 저장해서 디스크 기반 데이터베이스보다 훨씬 빠릅니다.
다양한 용도: 캐시(Cache), 세션(Session) 저장소, 실시간 순위표, 메시지 큐 등으로 많이 사용됩니다.
원자적으로 연결이 되어서 해킹이 막혀있다는 건? 문제 Z
:"원자적"이란 여러 요청이 동시에 들어와도 데이터가 꼬이지 않고, 한 번에 하나의 작업만 처리되도록 보장
if cache.setnx(throttle_key, 1): cache.expire(throttle_key, timedelta(seconds=THROTTLE_WINDOW))
kwargs["account"] = ...
kwargs는 파이썬 함수의 키워드 인자 딕셔너리입니다.
이 줄은,
파이썬 딕셔너리로 변환한 세션 정보를 account라는 이름으로 함수 인자에 추가하는 역할





