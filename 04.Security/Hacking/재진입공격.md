
## 🔄 **재진입 공격이란?**

재진입 공격은 스마트 컨트랙트가 **외부 컨트랙트를 호출하는 동안**, 해당 외부 컨트랙트가 **원래 함수를 다시 호출**하여 예상치 못한 동작을 유발하는 공격입니다.

## ⚠️ **공격 메커니즘**

### **취약한 코드 예시:**

```solidity
contract VulnerableBank {
    mapping(address => uint256) public balances;
    
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }
    
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "잔액 부족");
        
        // ❌ 위험: 상태 업데이트 전에 외부 호출
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "전송 실패");
        
        // 상태 업데이트가 너무 늦음
        balances[msg.sender] -= amount;
    }
}
```

### **공격자 컨트랙트:**

```solidity
contract Attacker {
    VulnerableBank public bank;
    uint256 public constant ATTACK_AMOUNT = 1 ether;
    
    constructor(address _bankAddress) {
        bank = VulnerableBank(_bankAddress);
    }
    
    function attack() public payable {
        // 1. 최소한의 예금
        bank.deposit{value: ATTACK_AMOUNT}();
        
        // 2. 출금 시작 (재진입 트리거)
        bank.withdraw(ATTACK_AMOUNT);
    }
    
    // 3. fallback 함수에서 재진입 발생
    receive() external payable {
        if (address(bank).balance >= ATTACK_AMOUNT) {
            bank.withdraw(ATTACK_AMOUNT); // 🔄 재귀 호출!
        }
    }
}
```

## 🔍 **공격 과정 단계별 분석**

```
1️⃣ 공격자가 withdraw(1 ETH) 호출
   └─ 잔액 확인: ✅ (1 ETH 보유)

2️⃣ msg.sender.call{value: 1 ETH}() 실행
   └─ 공격자의 receive() 함수 호출됨

3️⃣ receive() 함수에서 withdraw(1 ETH) 재호출
   └─ 잔액 확인: ✅ (아직 차감되지 않음!)

4️⃣ 또다시 msg.sender.call{value: 1 ETH}() 실행
   └─ 무한 루프...

5️⃣ 컨트랙트 잔액이 소진될 때까지 반복
```

## 🏛️ **The DAO 해킹 (2016년)**

**역사상 가장 유명한 재진입 공격:**

- **피해액**: 약 6천만 달러 (360만 ETH)
- **결과**: 이더리움 하드포크로 이더리움 클래식(ETC) 탄생
- **취약점**: splitDAO 함수의 재진입 버그

```solidity
// The DAO의 취약한 코드 (단순화)
function withdraw() {
    uint amount = balances[msg.sender];
    
    // 재진입 취약점
    if (msg.sender.call.value(amount)()) {
        balances[msg.sender] = 0;  // 너무 늦음!
    }
}
```

## 🛡️ **방어 방법들**

### **1. Checks-Effects-Interactions 패턴**

```solidity
function withdraw(uint256 amount) public {
    // 1️⃣ Checks: 조건 확인
    require(balances[msg.sender] >= amount, "잔액 부족");
    
    // 2️⃣ Effects: 상태 변경 먼저!
    balances[msg.sender] -= amount;
    
    // 3️⃣ Interactions: 외부 호출은 마지막에
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "전송 실패");
}
```

### **2. ReentrancyGuard 사용**

```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract SecureBank is ReentrancyGuard {
    mapping(address => uint256) public balances;
    
    function withdraw(uint256 amount) public nonReentrant {
        require(balances[msg.sender] >= amount, "잔액 부족");
        
        balances[msg.sender] -= amount;
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "전송 실패");
    }
}
```

### **3. Pull over Push 패턴**

```solidity
contract SecureBank {
    mapping(address => uint256) public balances;
    mapping(address => uint256) public withdrawalAllowance;
    
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount);
        
        // 출금 허용량만 설정
        withdrawalAllowance[msg.sender] += amount;
        balances[msg.sender] -= amount;
    }
    
    function pullPayment() public {
        uint256 amount = withdrawalAllowance[msg.sender];
        withdrawalAllowance[msg.sender] = 0;
        
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
    }
}
```

## 🔄 **재진입 공격의 변형들**

### **1. Single Function Reentrancy**

- 같은 함수를 재귀적으로 호출

### **2. Cross-Function Reentrancy**

```solidity
// 취약한 예시
contract Vulnerable {
    mapping(address => uint256) public balances;
    
    function withdraw() public {
        uint256 amount = balances[msg.sender];
        msg.sender.call{value: amount}("");
        balances[msg.sender] = 0;
    }
    
    function transfer(address to, uint256 amount) public {
        require(balances[msg.sender] >= amount);
        balances[to] += amount;
        balances[msg.sender] -= amount;  // 다른 함수 상태 영향
    }
}
```

### **3. Cross-Contract Reentrancy**

- 여러 컨트랙트 간 상태 공유로 인한 재진입

### **4. Read-Only Reentrancy**

```solidity
// ERC-4626 볼트의 취약점 예시
function balanceOf(address user) public view returns (uint256) {
    // 재진입 중 일관성 없는 상태 반환 가능
    return vault.totalAssets() * shares[user] / totalSupply();
}
```

## 🚨 **최신 재진입 공격 사례들**

### **1. Cream Finance (2021)**

- **피해액**: 1억 3천만 달러
- **방식**: 크로스 프로토콜 재진입

### **2. Fei Protocol (2022)**

- **피해액**: 8천만 달러
- **방식**: 복합 재진입 공격

### **3. Paraluni (2022)**

- **피해액**: 170만 달러
- **방식**: 읽기 전용 재진입

## 💡 **개발자를 위한 체크리스트**

```solidity
// ✅ 올바른 패턴
function secureWithdraw(uint256 amount) external nonReentrant {
    // 1. 모든 조건 확인
    require(amount <= balances[msg.sender], "잔액 부족");
    require(amount > 0, "0보다 큰 금액 필요");
    
    // 2. 상태 변경
    balances[msg.sender] -= amount;
    
    // 3. 이벤트 발행
    emit Withdrawal(msg.sender, amount);
    
    // 4. 외부 호출 (가장 마지막)
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "전송 실패");
}
```

## 🔧 **검증 도구들**

1. **Slither**: 정적 분석 도구
2. **MythX**: 재진입 패턴 탐지
3. **Echidna**: 퍼징 테스트
4. **Manticore**: 심볼릭 실행

재진입 공격은 블록체인 보안의 기초이자 가장 치명적인 공격 중 하나입니다. **항상 상태 변경을 외부 호출보다 먼저 수행**하는 것이 핵심 방어 원칙입니다!